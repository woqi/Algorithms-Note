### 数据类型

string、number、boolean、undefined、null、bigint、symbol、object

表示对象为空使用 null，不存在的对象
非对象使用 undefined，声明，未赋值

bigint 出现原因
js number 默认为双精度浮点数，精度有限，位数有限
`123456n`表 bigint
但是 bigint 只支持整数

symbol 实现什么场景 做库的时候使用

### var、let、const

暂时性死区：不能再声明前调用
var 有变量提升，函数优先于变量，可重复声明，不存在暂时性死区
let、const 无变量提升，不可以重复声明相同变量，存在暂时性死区
const 声明之后的值不能改变，立即初始化 **随即会问为什么不能改变**不允许修改指向的内存地址，赋值会改变内存指向

### 闭包

- 概念
  闭包 = 函数 + 函数能够访问的自由变量
  函数加自由变量
  自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量，变量在函数外部
- 解决了：
  避免污染全局环境、提供对局部变量的间接访问`count+1`不能`count-=1`
  维持变量，使其不被垃圾回收
  简单好用
  但是低版本浏览器使用不当会导致制内存泄漏

```
const x = function(){
  var count
  function add(){
    count += 1
  }
}()
```

引用了另一个函数作用域的变量

```js
function fn(fnArg) {
  return function (obj1) {
    let value = obj1[fnArg] //此处是闭包
  }
}
```

内部匿名函数包含 fn 的作用域链

### 箭头函数与普通函数的区别

函数体内的 this   对象，是定义时所在的对象，而不是使用时所在的对象。
不可以当作构造函数，也就是说，不可以使用 new   命令，否则会抛出一个错误。
不可以使用 arguments   对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。不可以使用 yield  命令，因此箭头函数不能用作 Generator 函数。没有 prototype  属性，即没有原型链(因为它不能当做构造函数)。不能通过 call、apply、bind 去绑定 this 的指向
**此处会衍生一些列 5 个问题**

### call、apply、bind

共同点：第一个参数指定 this 指向
call 接受参数列表
apply 接受参数数组
bing 返回新函数，新函数参数自定

```js
function bind(asThis) {
  var fn = this //记录this
  var args = slice.call(arguments, 1)
  if (typeof fn != 'function') {
    throw new Error('bind需使用在函数上')
  }
  function resFn() {
    var args2 = slice.call(arguments, 0)
    return fn.apply(resFn.prototype.isPrototypeOf(this) ? this : asThis, args.concat(args2))
  }
  resFn.prototype = fn.prototype
  return resFn
}
```

### new 的时候会发生以下几件事情

假设 `let newPerson = new Person|| let newPerson2= new Person()`不传参就不加括号 1.内存中创建了一个新对象 2.新对象 newPerson 内部的 Prototype 被赋值为构造函数 Person 的 Prototype 属性 3.此时构造函数的 this 指向 newPerson 4.执行的是构造函数内部代码 5.若构造函数返回非空对象，则返回该对象，否则返回 newPerson

### `__proto__` 、prototype、constructor 区别

`__proto__、constructor`是对象属性，
`prototype`是构造函数属性，指向一块内存，内存中放着共有属性，去除会导致公共属性无立足之地
让该函数所实例化的对象都可以找到公用属性和方法
`__proto__`去除会导致对象不知道自己的公用属性有哪些，

```js
let obj = {
  toString: window.Object.prototype.toString
}
obj.toString()
```

### 截流

```js
const d = () => {
  console.log('q')
}
//点击时候使用 截流
const throttle = (fn, time) => {
  let timer = null
  return (...args) => {
    if (timer) {
      return
    }
    fn.call(undefined, ...args)
    timer = setTimeout(() => {
      timer = null
    }, time)
  }
}
const d2 = throttle(d, 3 * 1000)
```

### 防抖

```js
const f = () => {
  //回城过程中被攻击就会被打断
  console.log('回城')
}
//窗口拖动 防抖 回城被打断
const debonce = (fn, time) => {
  let timer = null
  return (...args) => {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn.call(undefined, ...args)
      timer = null
    }, time)
  }
}
const tp = debonce(f, 3 * 1000)
```

### 柯里化

```js
function _compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg
  }
  if (funcs.length === 1) {
    return funcs[0]
  }
  return funcs.reduce(
    (a, b) =>
      (...args) =>
        a(b(...args))
  )
}
```

- 面试实战遇到
  输入一系列函数，第二个以第一个函数返回值为入参，意为上一个函数作为下一个函数的参数
  本质是想问 compose 实现
  解法：reduce、for 循环
想把 var a = fn1(fn2(fn3(fn4(x)))) ---》var a = compose(fn1,fn2,fn3,fn4)(x)
```js
function com(...fnArgs) {
  if (fnArgs.length === 0) {
    return arg => arg
  }
  if (fnArgs.length === 1) {
    return fnArgs[0]
  }
  return fnArgs.reduce(
    (pre, next) =>
      (...args) =>
        pre(next(...args))
  )
}
```
