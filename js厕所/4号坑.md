### 实现 class

extends：继承拥有 Construct、原型的对象，继承普通构造函数
super：调用父类构造函数并将返回值赋给 this

```js
//es5 继承：
function Dog(name) {
  this.name = name
  this.legNuymber = 4
}
Dog.prototype.kind = '狗'
Dog.prototype.say = function () {
  console.log(`汪,我是${this.name},我有${this.legsNumber}条腿`)
}
Dog.prototype.run = function () {
  console.log(`有${this.legsNumber}条腿跑起来`)
}
let a = new Dog('xiao bai')
// es6:
class Dog2 {
  // #kind = '狗' // 私有属性
  // kind = '狗' // 等于在constructor写this.kind = '狗'

  constructor(name) {
    //初始化
    this.name = name
    this.legNuymber = 4
  }
  say = function () {
    console.log(`汪,我是${this.name},我有${this.legsNumber}条腿`)
  }
  run = function () {
    console.log(`有${this.legsNumber}条腿跑起来`)
  }
}
let a2 = new Dog2('xiao bai')
```

### 继承

```js
/*es5*/
function Animal(legsNum) {
  this.legsNum = legsNum
}
Animal.prototype.kond = '动物'
function Dog(name) {
  Animal.call(this, 4) //this.legsNum = 4
  this.name = name
}
//期望 Dog.prototype.__proto__ = Animal.prototype
/*创建临时对象 临时对象原型绑定到构造函数上 构造函数this指向临时对象 执行构造函数 没有返回值就返回临时对象*/
let F = function () {}
F.prototype = Animal.prototype
Dog.prototype = new Fn()
/*es6*/
class Animal {
  constructor(legsNum) {
    this.legsNum = legsNum
  }
}
class Dog extends Animal {
  constructor(name) {
    super(4) //传给父级,调用父类的构造函数
    this.name = name
  }
  say() {}
}
```

### this 类型题目解题思路

this 是 call 的第一个参数，改变 this 指向

```
f1() -->f1,call(undefinde)
f1('h1') -->f1.call(undefinde,'hi')
obj.child.say('h2')-->say.call(obj.child,'h2')
```

```js
/*问 1*/
var length = 4 //=== window.length = 4 var都会被改成window
function callback() {
  console.log(this.length) // 这步打出什么
}
const obj = {
  length: 5,
  method(callback) {
    callback() //执行 callback.call(undefinde)
  }
}
obj.method(callback, 1, 2) // callback函数作为参数传入

/*问 2*/
let arr = [
  function () {
    console.log(this)
  },
  2
]
arr[0]() // --->[0].call(arr)
new arr[0]() // new比this nb
```

### Object.create 实现

```js
Object.MyCreate = function (proto, propertiesObject) {
  if (typeof proto !== 'object' && typeof proto !== 'function') {
    throw new TypeError('Object prototype may only be an Object: ' + proto)
  } else if (proto === null) {
    throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.")
  }

  if (typeof propertiesObject !== 'undefined') throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.")

  function F() {}
  F.prototype = proto

  return new F()
}

let fn = (!function () {
  var a = ''
  return function () {
    console.log(a)
  }
})()
```

### for in 与 for of 区别

for of 不能遍历对象因为没有迭代器对象

### 如何暂停请求，随即会问到 axios.CancelToken 如何实现，随即问到 promise 如何暂停

原生 XMLHttpRequest.abort
axios.CancelToken
axios 基于原生实现，XMLHttpRequest.abort 执行后调用 reject 让 promise 失败
promise 如何暂停用 promise.race('需中断的 promise','reject 的 promise')
