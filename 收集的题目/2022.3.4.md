- 闭包
  函数与函数能访问到的自由变量构成，减少垃圾回收，不当使用造成老浏览器内存泄漏，

- es6 出现了哪些新特性
  现场答
  模板字符串、扩展符号、Map、Set、let、const

- let const var 区别
  现场答
  var 声明前置
  let a 不报错
  const b 报错
  a 再次赋值不报错，b 报错，const 的变量不能改变地址

- call apply bind 区别
  现场答
  call 第二个参数任意个数
  apply 需要确定个数，并只能写数组
  bind 可以返回一个新函数

- 箭头函数普通函数区别
  现场答
  在`let obj = {b: ()=>{}}`发生报错
  箭头函数 this 指向调用他的一方，在 obj.b 中指向了 b，设置事件会发生不生效的问题，
  不能作为构造函数，不能使用 call、apply、bind 改变 this 指向，没有 prototype

- map 和 object 区别
  map 的 key 可以是任意类型，比如数字、字符串、正则、函数。注重存取操作
  object 只能是字符串

- new 做了什么事情：
  现场答 new 做了五件事
  `let b = new A()`
  在内存中开辟 b 对象
  将 b.prototype = a.prototype
  将构造函数 a 的 this 指向了 b
  执行构造函数 a
  假设构造函数返回有值，就返回出该值，没有就返回 b

这个问题给他讲了两边，第一遍他没有听明白，我在自己再总结一套话吧

- 手写 promise 原理:实现细节，promise 有几种状态，他应该是想问如何实现，
  我最近确实没有怎么看 promise，如果答完这一题应该还会问 promise.all，promise.rase，答的很烂

- then 里有几个参数：面试官答 promise 里有两个参数，什么情况 resolve，什么情况 reject，
  答的很烂

- async，await 如何使用
  现场答

```js
async fnunction fn(){
 let res = await promiseFn()
}
```

- http 状态码：
  答了 200、300、400、500，问 304、403
- 强缓存协商缓存
  只记住了强缓存

- vue 有哪些通信方式，你们项目中常用的通信方式
  现场答：
  父子 props
  子父 emit
  祖辈孙辈：provide inject
  父子：$parent $child
  任意：vuex

- vue 生命周期及各自的作用
  紧张说的很混乱
- v-model 原理
  现场围绕 v-on v-bind 展开
- 自定义组件如何使用 v-model
  现场，主要在表单组件里使用，后续被询问有没有自己写过 vue 组件

- vue 双向绑定原理，想问的方面是问底层原理
  围绕 object.defineprototype

项目
问 mixin 他心理答案我猜是源码 mixin 实现，这部分答的也很烂

手写题

- 查找最大数
  `let arr = [29, 8, 17, 6, , 3, 19, 27, 81, 2, -6]`
  我当时想法是双指针去实现，参考接雨水，但是我忘记怎么写了，只写了一个循环，最后让说实现思路

```js
//以前写的答案
function findMax(arr) {
  //终止条件
  if (arr.length === 0) {
    return undefined
  } else if (arr.length === 1) {
    return arr[0]
  }
  //划分
  let c = Math.floor(arr.length / 2)
  let left = arr.slice(0, c)
  let leftMax = findMax(left)

  let right = arr.slice(c)
  let rightMax = findMax(right)

  //合并
  return leftMax > rightMax ? leftMax : rightMax
}

function findMax1(arr) {
  return arr.reduce((pre,cur)=>{
    return Math.max(pre, cur)
  })
}

function findMax2(arr) {
  return Math.max(...arr)
}

console.log(findMax(data))
```

- 函数 before(n,fn)
  n 指次数，fn 指函数

```js
let vote = before(3, function (name) {
  console.log(`${name}投票了`)
})

vote('a') //a投票了
vote('b') //a投票了
vote('c')
vote('d')

function control(fn, num) {
  let lock = 1
  return function () {
    if (lock <= num) {
      fn.apply(this, arguments)
      lock++
    }
  }
}
let pay = control((money)=> {
  console.log('支付', money)
},3)
pay(5)
pay(5)
pay(5)
pay(5)

```

现场答

```js
function before(n, fn) {
  return function (...args) {
    fn.call(this, ...args, n, fn)
    //后面不会了
  }
}
```

- 输出结果近似于 1000

```js
function sleep(time) {
  //
}
!(async () => {
  console.log(11)
  let old = new Data()
  await sleep(1000)
  console.log(new Date() - old)
})()
```

现场答

```js
function sleep(time) {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(), time)
  })
}
```
