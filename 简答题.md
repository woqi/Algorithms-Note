### 1.npm 模块安装机制，为什么输入 npm install 就可以安装对应的包

根据 package.json 文件安装

### 2.以下内容执行结果是什么并解释

```js
var a = { n: 1 }
var b = a
a.x = a = { n: 2 }
console.log(a.x) //undefine
console.log(b.x) //{n:2}
```

连等开始之前会把所有引用都保存下来，连等的过程中这些值不变，连等结束后再一起改变，
从后往前执行

### 3.数组里有十万个数据，取第一个和第十万个元素的时间相差多少

完全一样
数组是随机访问的，在内存中是一段连续的内存空间，首地址 arr+偏移量 i，cpu 计算加法时间相同

### 4.介绍三者判断数组的区别及劣势

`Object.prototype.toString.call() \\"[object Array]"`
结果是 string，数组作为 object 调用

`instanceof` 可以判断父类也可以判断子类，结果是 Boolean

`Array.isArray` 可判断普通数组还是继承来的数组，结果是 Boolean

```js
let arr1 = [1, 2]
class Myarr extends Array {}
let arr4 = new Myarr()
console.log(Object.prototype.toString.call(arr4)) //[object Array]
console.log(arr4 instanceof Array) //true
console.log(arr4 instanceof Object) //true
console.log(Array.isArray(arr4)) //true

arr1.constructor === Array //true
arr2.constructor === Array //false
```

区别：

`Array.prototype instanceof Array //false`

`Array.inArray(Array.prototype) //true`

### 5.sort 排序

简写 `arr.sort((a, b) =>a-b)`原因

```js
arr.sort((a, b) => {
  if (a < b) {
    return -344
  } else if (a > b) {
    return 0.23
  } else {
    return 0
  }
})
```

### 6.react-router 中 a 标签跟 Link 标签的区别，如何禁 a 默认事件，禁掉后如何实现跳转

区别：
Link 可以用于 web、react native、后台，不刷新页面，spa 单页面应用
a 刷新页面，单页面数据丢失
尽量用 link

```js
{
  e => {
    e.preventDefault()
    history.push('/aaa')
  }
}
;<Route path='/aaa' />
```

### 7.实现 sleep 函数，等待 1000ms，可以从 promise、generator、async 角度实现，本意问实现 promise

```js
function sleep(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms)
  })
}
(async () => {
  console.log(11)
  await sleep(2000)
  console.log(22)
})()
```

### 8.拍平数组，去除重复部分，得到升序不重复数组，`[[1,2,2],[3,4,5,5],[6,7,8,9[11,12,[12,13,[14]]]],10]`

```js
let res = []
let json = {}
flat1(arr5)
function flat1(a) {//拍平并去重
  for (let i = 0; i < a.length; i++) {
    if (typeof a[i] == 'number') {
      // if(!res.includes(a[i])){//低性能版
      //   res.push(a[i])
      // }
      if (!json[a[i]]) {
        //高性能
        res.push(a[i])
        json[a[i]] = true
      }
    } else {
      flat1(a[i])
    }
  }
}
//手写排序（冒泡）
for (let i = 0; i < res.length; i++) {
  for (let j = i; j > 0; j--) {
    if (res[j] < res[j - 1]) {
      //基础版
      // let tmp = res[j]
      // res[j] = res[j - 1]
      // res[j - 1] = tmp

      //炫技版本
      res[j] += res[j - 1]
      res[j - 1] = res[j] - res[j - 1]
    }
  }
}
console.log(res)
```

### 9.TCP 三次握手和四次挥手理解

建立连接 3-way handshake
主动断开连接 4-tmies close
### 10.合并数组

```js
let a1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']
let a2 = ['A', 'B', 'C', 'D']
//合并为
// ['A1','A2','A','B1','B2','B','C1','C2','C','D1','D2','D']

let res1 = []
while (a1.length || a2.length) {
  if (a1.length == 0) {
    res1 = [...res1, ...a2]
    break
  }
  if (a2.length == 0) {
    res1 = [...res1, ...a1]
    break
  }
  if (a2[0] == a1[0][0]) {
    res1.push(a1.shift())
  } else {
    res1.push(a2.shift())
  }
}
console.log('--', res1)
```

### 11. React/VUe 为什么在列表中写 key，作用是什么

视图层框架中的虚拟 dom 需要映射为真实 dom 是依据 key 作为标志进行连接
实践中 key 可以加速真实 dom 渲染，避免 mvvm 框架自己猜，强制刷新可以使用 key（动画的时候使用强制刷新）
Vue

### 12.Vue 的父组件和子组件生命周期钩子执行顺序是什么
渲染：
父beforeCreate-->父created-->父beforeMount-->子beforeCreate-->子created-->子beforeMount-->子mounted-->父mounted

子组件更新：
父beforeUpdate->子beforeUpdate->子updated->父updated

销毁：
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
### 13.JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串，输入整型1234，返回'4321'。要求必须使用递归函数调用，不能使用全局变量，输入函数只有一个入参，必须返回字符串
```js
function init(s){
  const next = parseInt(s/10)
  return next == 0 ? `${s}`:`${s%10}${init(next)}`
}
function init2(s){
  const str = num.toString()
  return str.length === 1 ? str : numberReverse(str.substring(1)) + str.substring(0, 1)
}
```
### 14.实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是否为 m，若存在则返回所在位置
`const find = (S, T) => S.search(T)`

### 17.分析比较opacity:0、visiblility:hidden、display:none优劣及使用场景
opacity:0 
透明度，元素依然存在，依然要渲染，可以交互，影响性能（排列、渲染）
visibility:hidden 
改变可视性，隐形，元素依然存在，浏览器保持空间但是不渲染，不可以交互，影响性能（排列）
display:none 
盒模型，彻底消失，不占据位置，不可以交互，不渲染，不影响性能（无）
### 18.HTTPS握手过程中，客户端如何验证证书合法性
防止中间人攻击，服务器存在的公钥无法解密，
服务器先检查证书，证书由CA颁发，验证证书的颁发机构、证书签名，
公钥加密客户端堆成秘钥，服务器使用私钥解密
公钥是无法解密的，只有拥有私钥才能解密
双方拥有共同秘钥
正式开始通信

（加密钥匙跟解密钥匙不相同，对外公开是公钥，服务器存放私钥
中间人只有公钥没有服务器的私钥
通过rsa秘钥交换）
### 19.模拟实现深拷贝，并考虑对象互相引用一级Symbol拷贝的情况
`···`浅拷贝，本质是循环
深克隆本质是在复制的时候每一项都克隆，而不是只克隆一层
克隆的内容：数组、json、系统对象、Data、RegExp、自定义的class、Symbol
```js
//自定义的class深克隆例子
class Preson{
  constructor(name,age){
    //为了深克隆
    if(arguments.length===1 && arguments[0] instanceof Preson){
      let p = arguments[0]
      this.name = p.name
      this.age = p.age
    }else{
      this.name = name
      this.age = age
    }
  }
}
let p1 = new Preson('hehe',20)
let p2 = new Preson(p1)
p2.age = 30
console.log(p1)//age: 20
console.log(p2)//age: 30
```
克隆Symbo要点
```js
let s1 = Symbol()
let s2 = Symbol()
s1===s2 //false
//想让两者相等
let s1 = Symbol().for('lala')
let s2 = Symbol().for(s1.description)
s1===s2 //true
```
```js
function clone(data) {
  if (typeof data === 'symbol') {//symbol，symbol是非object的基本类型
    return Symbol().for(data.description)
  } else if (typeof data != 'object') {//基本类型 
    return data
  } else if (data instanceof Array) {// Array
    return data.map(i => clone(i))
  } else if (data.constructor === Object) {//避免 new Date，处理json
    let res = {}
    for(let key in data){
      res[key] = clone(data[key])
    }    
    return res
  } else {
    //系统对象及自定义对象 类似于class
    return new data.constructor(data)
  }
}
//互相引用--->防止形成环
```
### 20.聊聊Vue双向绑定数据，Model与View如何相互改变
vue2 defineProperty
vue3 Proxy
vue监听视图变化，监听input事件
v-model ==>@input + :value
```js
class Vue2{
  constructor(options){
    const {data} = options
    const _data = data()//运行
    for (const key in _data) {
      Object.defineProperty(this,key,{
        get(){
          return _data[key]
        },
        set(newVal){
          _data[key] = newVal
          console.log('可以渲染')
        }
      })
    }
  }
}
let vm = new Vue2({
  data(){
    return {a:12,b:5}
  }
})
// console.log(vm.a)

class Vue3{
  //Proxy自己是一个对象
  constructor(options){ //可以返回值,只能返回对象,意味着可以返回Proxy
    const {data} = options
    const _data = data()
    return new Proxy(_data,{
      get(obj, name){ // get中的参数是_data,name是某一个值
        return obj[name]
      },
      set(obj,name,value){//value是新值
        obj[name] = value
      }
    })
  }
}

let vm2 = new Vue3({
  data(){
    return {a:122,b:456}
  }
})
vm2.a++
console.log(vm2.a)
```
### 23.在全局作用中用const和let生命的变量不在window上，那到底在哪里？如何获取？
var出来的变量严格来说不在window上
对于浏览器来说global===window
其他环境里不是这种表现

scopes作用域，是程序一个内部的状态，无法从外界访问

const和let在[[Scope]]上，

直接访问
### 24 写出如下代码打印结果
```js
function changeObjProerty(o){
  o.siteUrl = 'baidu'//o还是原来的地址，与webSite地址一致
  o = new Object()//o赋予了一个新地址
  o.siteUrl = 'google'//新地址对应的siteUrl跟老地址不同
}
let webSite = new Object()
changeObjProerty(webSite)
console.log(webSite.siteUrl)//'baidu'
```
```js
function show(a){
  //1 改里面的东西有效
  //a.a+=5

  //2 改本身无效
  a={a:17}
}
let json={a:12}
show(json)
console.log(json)//12
```
js有两种值字面量（也可称为基本量、直接量）与对象

`let a = 12` 一眼可以看出是什么类型，属于字面量，

`let b`,b无法得知是什么，此时b在电脑里，是存的内存地址，所以在你修改b，内存地址没有改变，地址找到的内容去修改，直接修改等于不用以前的地址，诞生一个新地址，所以无法赋值
### 25.介绍深度优先广度遍历，如何实现
两者算法在图上使用，树是一种无环图
图遍历中有四种
两种常用为深度优先、广度优先
深度优先：

沿着第一条边走（子节点也是），所有相邻节点结束，再试第二条边

代码链接 ./简答题1.js
 
广度优先：

沿着所有相邻的边走一遍

代码链接 ./简答题1.js

### 26.React和Vue的diff时间复杂度从O(n^3)优化到O(n),那么O(n^3)和O(n)如何计算出来
父节点改变，整棵树扔掉
O(n^3)：老树循环一遍`n`，老新对比，每一个节点在新节点中查找严格说`n*log(n)`,最优`n*log(n)`，html都是手写只能`n*n`

O(n):html可能最多达到10多层的层级，但是节点很多，遍历整个树最大是`10*n`,react和vue，父节点改变就扔掉下面的整棵树，最大则为`n`，

### 27.在输入框中如何判断输入的是一个正确的网址
```js
<input id="txt"/>
let txt = document.getElementById('txt')
txt.oninput = function(){
  let str = txt.value
  let re = /https?:\/\/([a-z0-9\-]+\.)+[a-z]{2,6}(\/[a-z0-9%=\.]*)*$/i
  if(re.test(str)){
    txt.style.background = 'green'
  }else{
    txt.style.background = 'red'

  }
  // http://js.jirengu.com/ruhoxuwenu
}
```
### 28.为什么通常在发送数据埋点请求的时候使用的是1x1像素的透明gif图
数据埋点：
1.发送请求

可能会受到跨域，安全性软件限制

2.img
```
<img src="http://www.b.com/1.jpg?a=122"/>
```
开空nginx把数据收集在日志中，格式化后，定期的拉取数据，防止阻塞

1x1像素的透明gif：因为体积小，这个图片只是用来请求，字节大小:jpg>png>gif
gif可以做到最小43个字节，jpg文件头部过大，png因高清导致字节大

img数据量是最小的，ajax跨域需要设置请求头，空文件会导致画面不友好

### 29.已知数据格式，实现一个函数fn找出链条中所有的父级
```js 
const value = '112'
function fn(value){
  let str = ''
  let arr = []
  for (let i = 0; i < value.length; i++) {
    str += value[i]
    arr.push(str)
  }
  return arr
}
fn(value)//输出[1,11,112]
```
### 30.(头条微医) Async/Await 如何通过同步方式实现异步
```js
async function show2() {
  console.log(12)
  let data1 = await request('/data1')
  let data2 = await request('/data2')
  let data3 = await request('/data3')
  console.log(data1, data2, data3)
  return 55
}
function show2() {
  return new Promise((resolve, reject)=>{
    console.log(12)
    request('/data1').then(data1=>{
      request('/data2').then(data2=>{
        request('/data3').then(data3=>{
          console.log(data1, data2, data3)
          resolve(55)
        })
      })
    })
  })
}
```
### 31.介绍toke加密


### 33.介绍http中间人攻击
英文简称:MITM
用户发送请求到服务器，中间人在用户到服务器之间发送攻击，接收用户发送的东西，中间人将用户数据发送至服务器，攻击的方法有dns污染、篡改路由表、伪装路由。
如何防范中间人攻击：
- 自我识别，https登陆网站会有一个证书，用户发送信息的时候会通过网站证书里的公钥加密，来到中间人这里，中间人没有服务器的私钥，无法解开
- 加密后的数据传输，防止数据被窃取
### 34.介绍http握手过程
对称加密：性能更高，类似于网银，必须得线下完成
非对称加密：比对称加密低

用户生成接下来使用的临时秘钥，临时秘钥+网站证书中的公钥生成密文，密文发送到服务器，由密文+服务器私钥解密
服务器也有了临时秘钥，此次交换秘钥结束后，后续的交互就由对称加密完成

### 35.如何解决移动端Retina屏幕1px像素问题
Retina分辨率高
移动端屏幕有两个尺寸：物理尺寸，逻辑尺寸
meta里viewport指定逻辑分辨率是多少，物理尺寸跟逻辑尺寸间有换算
可以使用背景图，border-background，可以用图片作为一像素的边框
### 36双向绑定和vuex是否冲突
不冲突，
vuex是一个单项数据流，vue是双向数据绑定，两者完全没有关系
- vue
view视图层 <input/> {{a}}
model数据层 data(){return a:12}
model--->view model a=12，model发生变化会同步到view
view--->model <input v-modle="a"> imput输入什么值(input输入的值都会被转为字符串) model中a会变成这个值
view可以把自动把数据上的变化同步到model上
- vuex
component--->对mutation/action提交数据--->完成对state的修改---->修改组件，
组件无法直接修改state，action无法直接调用组件

### 37(京东快手)两数之和
