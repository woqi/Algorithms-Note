### React组件生命周期
//函数组件没有生命周期
#### 挂载阶段的钩子 //按执行顺序书写：
constructor、static getDerivedStateFromProps()、render()、componentDidMount()//组件已经真实被渲为真实DOM中
#### 更新阶段的钩子 //按执行顺序书写：
static getDerivedStateFromProps()：new props、setState、forceUpdate()//强制更新 都会调用
shouldComponentUpdate：new props、setState、都会调用
render、getSnapshotBeforeUpdate、componentDidUpdate
#### 卸载阶段：
componentWillUnmount

### React如何实现组件通信
父子：props
爷孙：两层父子通信，Context.Provider和Context.Consumer
任意：Redux、Mobx、Recoil

### 为什么 useState 不能在判断语句中声明？

react 中的 state 用链表关联
假设有 A、B、C 三个 state，B 在判断语句中，A、B 能及时更新，C 不会更新，
A.next->B，B.next->C

### setState 是同步还是异步的

对于 class 组件想拿到状态更新后的值在 componentDidMount()、componentDidUpdate()中执行，
函数组件在 useEffect 函数回调中执行
batchedUpdates 触发多个 this.setState 合并为一个处理
想跳出 batchedUpdates 处理将`this.setState({num:this.state.num+1})`放入 setTimeout、setInterval
此时将 executionContext=nocontext，优先级为同步优先级，触发同步更新，
生命周期函数、自己定义的函数、Dom 原生事件为异步，因为此时进入的是 batchedUpdates 处理
setTimeout、setInterval 属于异步函数，异步开始执行的时候同步任务早已结束，已经不在 batchedUpdates 处管辖范围内

### React Hooks vs Component

源码中通过 isReactComponent 区分两者
hooks 解决了 class 同一段代码需要拆分在不同生命周期里执行，逻辑难以复用，减少组件结构的修改

### React 中的 useCallback 和 useMemo 有什么区别，什么情况下需要用 useCallback

useCallback 缓存函数但不调用，函数对依赖项的缓存
优化子组件防止子组件重复渲染

useMemo 缓存函数返回值，源码中该函数有两个参数一个是函数一个是依赖项，将执行结果加入缓存返回
可以优化当前组件也可以优化子组件

### useRef 也能做，为什么要用 useState 呢？

useRef 不会引起渲染

### 虚拟 DOM 原理是什么

- 是什么
  虚拟 DOM 就是虚拟节点，React 用 JS 对象模拟真实 DOM 节点，然后将其渲染成真实 DOM 节点
- 如何做**稍微记一下代码**
```js
/*html节点*/
<div id='x'>
  <span class='span'>span</span>
</div>
/*jsx会转换成以下内容*/
{
  tag: 'div',
  props: {
    id: 'x'
  },
  children: [
    {
      tag: 'span',
      props: {
        className: 'span'
      },
      children: ['hi']
    }
  ]
}
/*jsx语法被转译为createElement*/
React.createElement('div',{id:'x'},
  React.createElement('span',{class:'span'},'hi')
)
/*虚拟渲染为真实dom
若为字符串或者数字，创建文本节点
创建真实DOm
设置属性
遍历子节点，并获取创建真实DOM，插入到当前子节点，
虚拟DOM中缓存真实DOM节点
返回DOM节点
注意：如果节点发生变化，并不会直接把虚拟节点渲染到真实节点，二十先经过diff算法得到patch再更新到真实的节点上
*/
```

- 解决了
  Dom 操作性能问题，通过虚拟 Dom 和 diff 算法减少不必要的 Dom 操作，保证性能不太低
  Dom 操作不方便问题，以前需要记 API，现在只有 setState
- 优点
  为 react 带来跨平台能力，虚拟节点除了渲染成真实 Dom 也可以渲染为其他东西
  让 Dom 操作整体性能更好，减少不必要的 Dom 操作
- 缺点
  React 为 Dom 创造了合成事件跟原生 Dom 事件不太一样，React 都绑定到根元素，自动实现事件委托，用合成时间和原生 DOm 事件可能会出 bug


### React Fiber 具体做了哪些工作

### React 解决了什么问题

### React Hooks 的原理

### redux 单向数据流有哪些优势，redux 中间件实现原理

### React HOC vs renderProps

### React router 的两种模式模式，怎么动态获取路由上的 id

### React 的 purecomponent 和 component 的区别

### React diff 节点对比的过程 | React diff 节点移动的具体过程

### 附加 useEffect(fn,[])与 componentDidMount 有什么区别

fn 依赖[]
计算出状态变化位于 render 阶段
将状态变化渲染在识图中属于 commit 阶段
render 通过 effect（flags）的数据结构传递给 commit 阶段

需要插入 DOM 的元素增加 placement 的 effect
需要更新 DOM 的元素增加 Update 的 effect
需要删除增加 deletion 的 effect
更新 ref 属性添加 ref effect

有 useEffect 回调的增加 passive effect
useEffect(fn) 在 mount、update 创建 passive effect
useEffect(fn,[]) 在 mount 创建 passive effect
useEffect(fn,[dep]) mount、dep 变化时创建 passive effect

class 组件 mount 时创建 placement effect
不同的 effect 进入 commit 阶段
commit 分为渲染视图前、ing、后
beforeMutation
mutation
layout

placement(增加 DOM) 先进入 mutation appendChild 后进入 layout 调用 compoentDidMount
passive 会在 commit 三个子阶段执行完毕后异步调用 useEffect

useEffect(fn,[])在 commit 阶段完成后异步调用
componentDidMount 在 commit 中完成 layout 子阶段同步调用
useLayoutEffect(fn,[])会在 layout 阶段同步调用

