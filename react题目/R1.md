### React组件生命周期
//函数组件没有生命周期
#### 挂载阶段的钩子 //按执行顺序书写：
constructor、static getDerivedStateFromProps()、render()、componentDidMount()//组件已经真实被渲为真实DOM中
#### 更新阶段的钩子 //按执行顺序书写：
static getDerivedStateFromProps()：new props、setState、forceUpdate()//强制更新 都会调用
shouldComponentUpdate：new props、setState、都会调用
render、getSnapshotBeforeUpdate、componentDidUpdate
#### 卸载阶段：
componentWillUnmount

### React如何实现组件通信
父子：props
爷孙：两层父子通信，Context.Provider和Context.Consumer
任意：Redux、Mobx、Recoil

### 为什么 useState 不能在判断语句中声明？
react 中的 state 用链表关联
假设有 A、B、C 三个 state，B 在判断语句中，A、B 能及时更新，C 不会更新，
A.next->B，B.next->C

### setState 是同步还是异步的
对于 class 组件想拿到状态更新后的值在 componentDidMount()、componentDidUpdate()中执行，
函数组件在 useEffect 函数回调中执行
batchedUpdates 触发多个 this.setState 合并为一个处理
想跳出 batchedUpdates 处理将`this.setState({num:this.state.num+1})`放入 setTimeout、setInterval
此时将 executionContext=nocontext，优先级为同步优先级，触发同步更新，
生命周期函数、自己定义的函数、Dom 原生事件为异步，因为此时进入的是 batchedUpdates 处理
setTimeout、setInterval 属于异步函数，异步开始执行的时候同步任务早已结束，已经不在 batchedUpdates 处管辖范围内

### React Hooks vs Component
源码中通过 isReactComponent 区分两者
hooks 解决了 class 同一段代码需要拆分在不同生命周期里执行，逻辑难以复用，减少组件结构的修改

### React 中的 useCallback 和 useMemo 有什么区别，什么情况下需要用 useCallback

useCallback 缓存函数但不调用，函数对依赖项的缓存
优化子组件防止子组件重复渲染

useMemo 缓存函数返回值，源码中该函数有两个参数一个是函数一个是依赖项，将执行结果加入缓存返回
可以优化当前组件也可以优化子组件

### useRef 也能做，为什么要用 useState 呢？
useRef 不会引起渲染

### 受控组件、非受控组件
非受控组件：将真实数据存在dom节点中，减少代码量
受控组件：state成为数据源，引发input内容改变

### 虚拟 DOM 原理是什么

- 是什么
  虚拟 DOM 就是虚拟节点，React 用 JS 对象模拟真实 DOM 节点，然后将其渲染成真实 DOM 节点
- 如何做**稍微记一下代码**
```js
/*html节点*/
<div id='x'>
  <span class='span'>span</span>
</div>
/*jsx会转换成以下内容*/
{
  tag: 'div',
  props: {
    id: 'x'
  },
  children: [
    {
      tag: 'span',
      props: {
        className: 'span'
      },
      children: ['hi']
    }
  ]
}
/*jsx语法被转译为createElement*/
React.createElement('div',{id:'x'},
  React.createElement('span',{class:'span'},'hi')
)
/*虚拟渲染为真实dom
若为字符串或者数字，创建文本节点
创建真实DOm
设置属性
遍历子节点，并获取创建真实DOM，插入到当前子节点，
虚拟DOM中缓存真实DOM节点
返回DOM节点
注意：如果节点发生变化，并不会直接把虚拟节点渲染到真实节点，二十先经过diff算法得到patch再更新到真实的节点上
*/
```

- 解决了
  Dom 操作性能问题，通过虚拟 Dom 和 diff 算法减少不必要的 Dom 操作，保证性能不太低
  Dom 操作不方便问题，以前需要记 API，现在只有 setState
- 优点
  为 react 带来跨平台能力，虚拟节点除了渲染成真实 Dom 也可以渲染为其他东西
  让 Dom 操作整体性能更好，减少不必要的 Dom 操作
- 缺点
  React 为 Dom 创造了合成事件跟原生 Dom 事件不太一样，React 都绑定到根元素，自动实现事件委托，用合成时间和原生 DOm 事件可能会出 bug


### React Fiber 具体做了哪些工作

### React如何实现时间切片
react中油许多微小的任务，即所有工作中的fiber节点，执行调度工作循环、计算工作循环，执行每一个工作中的fiber，但是每5毫秒，跳出工作循环，运行异步Message Channel(浏览器提供的一种数据通信接口)的port.postMessage(),检查是否存在事件响应、有更高优先级任务执行，如果有则执行，没有则重新创建循环，执行剩下的fiber
#### 为什么vue不用时间切片

### React 解决了什么问题
传统UI操作关注太多细节，应用储层序状态分散在各处，难以追踪维护
例子 传统jQuery局部刷新，react整体刷新
用组件描述UI
单向数据流
错误提示完善 

### React Hooks 的原理

### redux 单向数据流有哪些优势，redux 中间件实现原理
便于管理state

### React HOC vs renderProps
**renderProps：**用于告知组件需要渲染什么内容的函数prop，通过一个函数将class组件的state作为props传递给纯函数组件
```js
const A extends React.Component{
  state = {...}
  render(){
    return ( <>{this.props.render(this.state)}</>)
  }
}
const B = ()=>{
  <A render={state=><span>bComponent---{...state}</span>}>
  </A>
}
```
- 注意 
外层为React.PureComponent，render传递的组件为React.Component，因浅比较props总会得到false，内部用一个方法去接Component render的内容，再传给PureComponent
外层
- 缺陷
层级嵌套，无法在 return 语句外访问数据

**React HOC：**将组件作为参数并返回新组件，给原有组件添加额外的功能，主要是添加功能，可以多层嵌套，纯函数返回值为组件
- 注意
不要在render里用HOC，静态方法需要另行拷贝，hoist-non-react-statics 库或者 单独导出静态方法，ref不被传递
- 缺陷
多个HOC一起使用时，无法判断子组件props来源于哪个HOC，易产生同名命名，加深组件层级
```js
const A = wrappedComponent=>{
  class HOC extends React.component{
    state = {...}
    render(){
      return ( <wrappedComponent {...this.props}/>)
    }
  }
  return HOC
}
const B = ()=>{
  return <div>hehe</div>
  </a>
}
const C = A(B)
```

### React router 的两种模式模式，怎么动态获取路由上的 id
BrowserRouter 不带
HashRouter 路径带'#'
组件参数 16.8之前版本 match.params，16.8之后useMatch

### React 的 purecomponent 和 component 的区别
PureComponent 会对 props 和 state 进行浅层比较，props 和 state 使用，shouldComponentUpdate()中的子组件将跳过所有子组件树props更新。

### 附加 useEffect(fn,[])与 componentDidMount 有什么区别

fn 依赖[]
计算出状态变化位于 render 阶段
将状态变化渲染在识图中属于 commit 阶段
render 通过 effect（flags）的数据结构传递给 commit 阶段

需要插入 DOM 的元素增加 placement 的 effect
需要更新 DOM 的元素增加 Update 的 effect
需要删除增加 deletion 的 effect
更新 ref 属性添加 ref effect

有 useEffect 回调的增加 passive effect
useEffect(fn) 在 mount、update 创建 passive effect
useEffect(fn,[]) 在 mount 创建 passive effect
useEffect(fn,[dep]) mount、dep 变化时创建 passive effect

class 组件 mount 时创建 placement effect
不同的 effect 进入 commit 阶段
commit 分为渲染视图前、ing、后
beforeMutation
mutation
layout

placement(增加 DOM) 先进入 mutation appendChild 后进入 layout 调用 compoentDidMount
passive 会在 commit 三个子阶段执行完毕后异步调用 useEffect

useEffect(fn,[])在 commit 阶段完成后异步调用
componentDidMount 在 commit 中完成 layout 子阶段同步调用
useLayoutEffect(fn,[])会在 layout 阶段同步调用



